package main

import (
	"encoding/json"
	"io"
	"log"
	"net/http"
	"os"
	"strings"

	_ "email_spammer/docs" // docs is generated by Swag CLI, you have to import it.

	"email_spammer/repo/clients/cloudmersive"

	"github.com/gorilla/mux"
	"github.com/prometheus/client_golang/prometheus/promhttp"
	httpSwagger "github.com/swaggo/http-swagger" // http-swagger middleware
	"go.uber.org/zap"
)

// EmailRequest представляет собой структуру запроса
type EmailRequest struct {
	Sender    string `json:"sender"`
	Recipient string `json:"recipient"`
	Body      string `json:"body"`
}

// ScanResponse представляет собой структуру ответа
type ScanResponse struct {
	IsMalicious bool   `json:"is_malicious"`
	Reason      string `json:"reason"`
}

// @Summary Scan a file
// @Description Scan a file via multipart/form-data
// @Accept multipart/form-data
// @Produce json
// @Param file formData file true "Upload file"
// @Success 200 {object} ScanResponse
// @Router /scan [post]
func ScanEmail(w http.ResponseWriter, r *http.Request, logger *zap.Logger) {

	r.ParseMultipartForm(10 << 20) //10 MB
	file, handler, err := r.FormFile("file")
	if err != nil {
		log.Println("error retrieving file", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer file.Close()
	dst, err := os.Create(handler.Filename)
	if err != nil {
		log.Println("error creating file", err)
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
	defer dst.Close()
	if _, err := io.Copy(dst, file); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	client := cloudmersive.NewClient()
	logger.Sugar().Infof("FileName %v", dst.Name())
	res, err := client.CheckFile(dst.Name())
	if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	response := ScanResponse{}
	logger.Sugar().Infof("resp: %v", res)
	if len(res) > 0 {
		response.IsMalicious = true
		response.Reason = res
	}

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func containsMalware(body string) bool {
	malwareKeywords := []string{"malware", "virus", "trojan"}
	for _, keyword := range malwareKeywords {
		if contains(body, keyword) {
			return true
		}
	}
	return false
}

func contains(s, substr string) bool {
	return strings.Contains(strings.ToLower(s), strings.ToLower(substr))
}

func main() {
	logger, _ := zap.NewProduction()
	defer logger.Sync()

	router := mux.NewRouter()

	router.HandleFunc("/scan", func(w http.ResponseWriter, r *http.Request) {
		ScanEmail(w, r, logger) // Передаем логгер в обработчик
	}).Methods("POST")
	router.PathPrefix("/swagger/").Handler(httpSwagger.WrapHandler)

	// Metrics for Prometheus
	router.Handle("/metrics", promhttp.Handler())

	logger.Info("Starting server on :8080")
	if err := http.ListenAndServe(":8080", router); err != nil {
		logger.Fatal("Failed to start server", zap.Error(err))
	}
}
